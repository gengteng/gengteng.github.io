---
title: Redis 学习笔记（基础）[WIP]
date: 2021-09-23 19:18:46
tags: ['Redis']
mathjax: true
---


## 1. 基本架构

一个键值数据库需要有哪些功能/结构/特性。

* 支持多种数据结构
* PUT、GET、DELETE、SCAN
* 设置过期
* 索引结构
* 对外接口，Socket、动态链接库等等
* 存储方式，内存、硬盘（持久化）
* 高可用
* 横向扩展
* 功能可扩展性

----

## 2. 数据结构

Redis 接收到一个键值对操作后，能以 **微秒** 级别的速度找到数据，并快速完成操作。

Redis 的值有如下数据类型：

* String（字符串）
* List（列表）
* Hash（哈希）
* Set（集合）
* Sorted Set（有序集合）

| 数据类型     | 数据结构 |
| ----------- | ----------- |
| String      | 简单动态字符串      |
| List        | 双向链表/压缩列表   |
| Hash        | 压缩列表/哈希表     |
| Set         | 整数数组/哈希表     |
| Sorted Set  | 压缩列表/跳表       |

Redis 使用一个全局的哈希表来保存所有键值对，可以在 $O(1)$ 的时间内查找到键值对。

一个哈希表就是一个数组，数组元素为哈希桶，每个哈希桶存放一个链表，连接着哈希值映射到该桶中的多个键值对。

```
｜0｜1｜2｜3｜4｜5｜
    |       |
    |       ---> entry4
    |
    ---> entry1 ---> entry2 ---> entry3
```

### 哈希冲突及rehash

当哈希冲突过多时，链表过长，导致查找效率下降，Redis会对哈希表进行rehash。

为了 **使 rehash 更高效**，Redis 使用了两个全局哈希表：哈希表 1 和 哈希表 2 。默认情况下使用哈希表 1 ，哈希表 2 没有分配空间，当键值对增多时，Redis开始进行rehash：

1. 给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；
2. 把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；
3. 释放哈希表 1 的空间。

然后使用哈希表 2 保存数据，下次rehash再使用哈希表 1 。

为 **避免一次性拷贝大量数据造成 Redis 线程阻塞**，Redis采用了渐进式rehash。

#### 渐进式rehash

Redis可以保持处理用户请求，每处理一个请求，就顺带将哈希表 1 中的一个桶的所有entries拷贝到哈希表 2 中。这样就能把一次性大量拷贝的开销，分摊到了多次请求中，避免了耗时可能造成的阻塞。

### 数据结构的操作效率

**整数数组** 和 **双向链表** 都是顺序读写，操作复杂度都是 $O(N)$。

#### 压缩列表

压缩列表表头有 **列表长度（zlbytes）**、**列表尾偏移量（zltail）**、**列表中entry个数（zllen）** 三个字段，表尾有一个 **zlend** 字段表示 **列表结束**。

```
| zlbytes | zltail | zllen | entry1 | entry2 | ... | entryN | zlend |
```

查找表头、表尾元素的复杂度为 $O(1)$，查找其他元素的复杂度为 $O(N)$。

#### 跳表

**跳表** 是在 **有序链表** 的基础上增加了多级索引，通过索引位置的几次跳转，实现数据快速定位。

```
 1 ----------------------> 27 -----------------------> 100 // 二级索引
 ↓                         ↓                           ↓
 1 --------> 11 ---------> 27 ---------> 50 ---------> 100 // 一级索引
 ↓           ↓             ↓             ↓             ↓
 1 --> 5 --> 11 --> 20 --> 27 --> 33 --> 50 --> 62 --> 100 --> 156 // 链表
```

**跳表** 的查找复杂度为 $O(logN)$。

### 时间复杂度

#### 数据结构的时间复杂度

| 数据结构 | 时间复杂度 |
| ------- | --------- |
| 哈希表 | $O(1)$ | 
| 跳表 | $O(logN)$ | 
| 双向链表 | $O(N)$ | 
| 压缩列表 | $O(N)$ | 
| 整数数组 | $O(N)$ | 

#### 不同操作的时间复杂度

1. **单元数操作是基础**。每一种集合类型对单个数据实现的增删改查操作，复杂度由数据结构决定。
2. **范围操作很耗时**。返回一个范围内的数据，复杂度一般是 $O(N)$，应尽量避免，可以使用 2.8 版本之后的 `HSCAN`、`SSCAN`、`ZSCAN` 等命令进行渐进式遍历。
3. **统计操作通常高效**。集合类型对集合中的元素个数由记录，例如 `LLEN`、`SCARD`。
4. **例外情况只有几个**。压缩列表和双向列表的会记录表头和表尾的偏移量，对它们的操作复杂度只有 $O(1)$，例如 `LPOP`、`RPOP`、`LPUSH`、`RPUSH`。

#### 问题

整数数组和压缩列表在查找时间复杂度方面并没有很大优势，为什么Redis还会把它作为底层数据结构？

主要有两方面原因：
1. 内存利用率。Redis 是内存数据库，大量数据存储在内存中，整数数组和压缩列表结构比较紧凑，相比链表结构占用内存更少，可以提高内存利用率。
2. 数组对CPU高速缓存支持更友好。集合元素较少时，使用内存紧凑的排列方式，可以利用CPU高速缓存，尤其在一个缓存行内（64字节）有更高效的访问效率。当元素数量超过阈值后，为避免复杂度太高，可以转为哈希表和跳表。

## 3. 高性能 IO 模型

Redis 的网络 IO 和键值对读写是由单个线程完成的；其他功能，例如持久化、异步删除、集群数据同步，是由额外的线程执行的。

Redis使用 **IO多路复用**，即一个线程处理多个 IO 流。

可能存在的瓶颈（来自Kaito）：

1. 单个请求耗时会导致后续所有请求阻塞等待，包括以下几种：
   * 操作bigkey，分配、释放内存（4.0推出了lazy-free，可以异步执行bigkey释放）
   * 使用复杂度较高的命令，排序、union、查询全量数据
   * 大量key集中过期
   * 淘汰策略，内存超过Redis内存上线，每次写入都要淘汰一些key，导致耗时变长
   * AOF 开启 always
   * 主从同步生成 RDB 时的 fork
2. 并发量大时，单线程处理客户端请求，无法利用多核（6.0推出了多线程，可利用多核CPU处理用户请求）