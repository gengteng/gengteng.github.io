---
title: Redis 学习笔记（基础）[WIP]
date: 2021-09-23 19:18:46
tags: ['Redis']
mathjax: true
---


## 1. 基本架构

一个键值数据库需要有哪些功能/结构/特性。

* 支持多种数据结构
* PUT、GET、DELETE、SCAN
* 设置过期
* 索引结构
* 对外接口，Socket、动态链接库等等
* 存储方式，内存、硬盘（持久化）
* 高可用
* 横向扩展
* 功能可扩展性

----

## 2. 数据结构

Redis 值有如下数据类型：

* String（字符串）
* List（列表）
* Hash（哈希）
* Set（集合）
* Sorted Set（有序集合）

| 数据类型     | 数据结构 |
| ----------- | ----------- |
| String      | 简单动态字符串      |
| List        | 双向链表/压缩列表   |
| Hash        | 压缩列表/哈希表     |
| Set         | 整数数组/哈希表     |
| Sorted Set  | 压缩列表/跳表       |

Redis 使用一个全局的哈希表来保存所有键值对，可以在 $O(1)$ 的时间内查找到键值对。

一个哈希表就是一个数组，数组元素为哈希桶，每个哈希桶存放一个链表，连接着哈希值映射到该桶中的多个键值对。

```
｜0｜1｜2｜3｜4｜5｜
    |       |
    |       ---> entry4
    |
    ---> entry1 ---> entry2 ---> entry3
```

### 哈希冲突及rehash

当哈希冲突过多时，链表过长，导致查找效率下降，Redis会对哈希表进行rehash。

为了 **使 rehash 更高效**，Redis 使用了两个全局哈希表：哈希表 1 和 哈希表 2 。默认情况下使用哈希表 1 ，哈希表 2 没有分配空间，当键值对增多时，Redis开始进行rehash：

1. 给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；
2. 把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；
3. 释放哈希表 1 的空间。

然后使用哈希表 2 保存数据，下次rehash再使用哈希表 1 。

为 **避免一次性拷贝大量数据造成 Redis 线程阻塞**，Redis采用了渐进式rehash。

#### 渐进式rehash

Redis可以保持处理用户请求，每处理一个请求，就顺带将哈希表 1 中的一个桶的所有entries拷贝到哈希表 2 中。这样就能把一次性大量拷贝的开销，分摊到了多次请求中，避免了耗时可能造成的阻塞。

### 数据结构的操作效率

整数数组和双向链表都是顺序读写，操作复杂度都是 $O(N)$。

压缩列表表头有列表长度（zlbytes）、列表尾偏移量（zltail）、列表中entry个数三个字段（zllen），表尾有一个 zlend 字段表示列表结束。

```
|zlbytes|zltail|zllen|entry1|entry2|...|entryN|zlend|
```

查找表头、表尾元素的复杂度为 $O(1)$，查找其他元素的复杂度为 $O(N)$。

----


## 4. AOF（Append Only File）

Redis 的 AOF 是写后日志，先执行命令，把数据写入内存，然后再记录日志。

不会阻塞当前写操作，执行完命令还没来得及记日志就宕机的话，会有数据丢失的风险。

```AOF
*3 --> 这个命令有三个部分
$3 --> 第一部分的长度
set --> 第一部分的内容
$5
hello
$5
world
```

### 三种写回策略

* Always，同步写回，每个命令执行完立马写回磁盘
* EverySec，每秒写回，写到AOF内存缓存，每秒写回一次
* No，写到AOF内存缓存，由操作系统决定何时将其写回

### 日志重写

当日志文件过大时，可以对日志进行重写。可以把某些多条修改同一个键值对的命令合并为一条。

重写流程：

1. 主线程 fork 出 bgrewriteaof 子进程，主线程在将新指令写入 AOF 缓存时，还会写入 AOF 重写缓存；
2. 子进程将 fork 拷贝出来的内存快照写成命令日志；
3. 写完后将AOF重写缓存中的日志写到这个新的日志中，然后就可以用这个新日志替换旧日志了。

### 其他要点

1. fork 使用的是操作系统的写时复制（Copy On Write）机制，并不会直接拷贝所有内存。但是会拷贝父进程的的内存页表，如果页表较大，可能导致阻塞。
2. 主进程在提供服务时，如果操作的是bigkey，写时复制会导致内存分配；如果开启了内存大页（huge page）机制，内存分配会产生阻塞。（所以使用Redis通常要关闭内存大页，其对使用 fork 的程序不友好）
3. AOF 重写可以使用 `bgrewriteaof` 命令手动执行，也由两个配置项控制自动触发：
   * auto-aof-rewrite-min-size：表示运行AOF重写的最小大小，默认为 64MB；
   * auto-aof-rewrite-percentage：当前AOF文件大小和上一次重写后AOF文件大小的差值，除以上一次重写AOF文件大小，即增量和上一次全量的比值，默认为 100。
  AOF 文件大小同时满足这两个配置项，会自动触发 AOF 重写。

----

## 5. 内存快照 RDB

把某一时刻的内存数据以文件的形式写到磁盘上，即快照。